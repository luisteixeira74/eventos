# Event Dispatcher com Testify Suite

> üìå Projeto de estudo e pr√°tica durante minha transi√ß√£o de stack PHP ‚Üí Go.  
> Neste reposit√≥rio, exploro conceitos avan√ßados como arquitetura de eventos, testes com `testify/suite`, integra√ß√£o com RabbitMQ e aplica√ß√£o de princ√≠pios SOLID ‚Äî tudo estruturado com foco em clareza e boas pr√°ticas para ambientes reais.

Este projeto implementa um mecanismo de **Event Dispatcher** em Go, com suporte a registro e gerenciamento de m√∫ltiplos handlers para eventos usando RabbitMQ como Queue. A testagem √© feita utilizando o poderoso recurso de **test suites do [Testify](https://github.com/stretchr/testify)**, permitindo testes mais organizados, reutiliz√°veis e leg√≠veis.

## Objetivo

Demonstrar como aplicar o padr√£o de eventos em Go de forma simples e test√°vel, utilizando a biblioteca `testify/suite` para:

- Evitar duplica√ß√£o de c√≥digo nos testes.
- Organizar os testes com setup automatizado.
- Manter a coes√£o e clareza entre diferentes casos de teste.

---

## Estrutura

### üì¶ `EventDispatcher`

Arquivo: `event_dispatcher.go`

- Estrutura respons√°vel por registrar, armazenar e limpar handlers associados a eventos.
- Impede o registro duplicado de handlers para o mesmo evento.

### üì¶ `EventDispatcherTestSuite`

Arquivo: `event_dispatcher_test.go`

- Test suite baseada em `testify/suite`.
- Inclui testes para:
  - Registro de handlers.
  - Registro duplicado (com erro esperado).
  - Limpeza de todos os handlers (`Clear()`).


## Executando os tests

go test ./...

### `RabbitMQ`

docker-compose up -d

RabbitMQ Web: `http://localhost:15672/`

- login: guest
- Passw: guest

[Cria√ß√£o da Fila e o Bind com Exchange √© feito no setup.go]

## Considera√ß√µes de Arquitetura

### üîÅ Padr√£o de Projeto: Observer

Este projeto aplica o **Observer Pattern (Padr√£o Observador)**, que define uma depend√™ncia "um-para-muitos" entre objetos:

> "Quando um objeto muda de estado, todos os seus dependentes s√£o notificados automaticamente."

- O `EventDispatcher` atua como o **sujeito (subject)**.
- Os handlers registrados s√£o os **observadores (observers)**.
- Ao executar `Dispatch(event)`, todos os handlers registrados para aquele tipo de evento s√£o acionados.

---

### ‚úÖ Princ√≠pios SOLID Aplicados

Este projeto tamb√©m reflete os princ√≠pios do SOLID:

- **S ‚Äî Single Responsibility Principle (SRP)**  
  Cada componente tem responsabilidade √∫nica.  
  O `EventDispatcher` apenas gerencia eventos e handlers, enquanto os handlers encapsulam a l√≥gica de resposta.

- **O ‚Äî Open/Closed Principle (OCP)**  
  O sistema √© aberto para extens√£o, mas fechado para modifica√ß√£o.  
  Novos handlers podem ser registrados sem alterar o c√≥digo existente.

- **L ‚Äî Liskov Substitution Principle (LSP)**  
  Todos os handlers implementam uma interface comum, podendo ser substitu√≠dos sem quebrar o funcionamento do dispatcher.

- **I ‚Äî Interface Segregation Principle (ISP)**  
  A interface de handler √© pequena e espec√≠fica (`Handle(event)`), sem obrigar implementa√ß√µes desnecess√°rias.

- **D ‚Äî Dependency Inversion Principle (DIP)**  
  O dispatcher depende de abstra√ß√µes (`EventHandler`) e n√£o de implementa√ß√µes concretas, promovendo baixo acoplamento e facilitando testes.

---

## üî≠ Pr√≥ximos passos

- Adicionar testes de integra√ß√£o com RabbitMQ.
- Separar l√≥gica de handlers em microservi√ßos distintos.
- Implementar versionamento de eventos.
- Criar integra√ß√£o com outros sistemas como notifica√ß√µes por e-mail ou logs estruturados.

---

